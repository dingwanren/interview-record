import{_ as i,c as t,o as l,ae as o}from"./chunks/framework.CgLBEkON.js";const u=JSON.parse('{"title":"项目难点亮点","description":"","frontmatter":{},"headers":[],"relativePath":"interview/project-highlights.md","filePath":"interview/project-highlights.md"}'),a={name:"interview/project-highlights.md"};function r(s,e,n,h,c,p){return l(),t("div",null,e[0]||(e[0]=[o('<h1 id="项目难点亮点" tabindex="-1">项目难点亮点 <a class="header-anchor" href="#项目难点亮点" aria-label="Permalink to &quot;项目难点亮点&quot;">​</a></h1><h2 id="工厂模式重构代码" tabindex="-1">工厂模式重构代码 <a class="header-anchor" href="#工厂模式重构代码" aria-label="Permalink to &quot;工厂模式重构代码&quot;">​</a></h2><p><strong>情境</strong>: 开发了一个 cloudos, OpenStack 资源所用的表格页面, 两个资源的表格构成基本相同,代码就都写在一个组件文件内, 但后续有多个资源需要实现类似的表格页面, 且表格配置,行列各有差异</p><p><strong>任务</strong>: 开发时若继续沿用之前写在同一文件的模式, 传给表格的配置对象就很乱, 而且一些(crud)方法中也需要去判断资源类型,重复代码多, 后面也不好去维护. 想有一种减少重复代码,结构清晰的方案</p><p><strong>行动</strong>: 利用工厂模式重构了代码,</p><ol><li>创建 TableFactory 类作为统一入口, 统一 new 它生成表格和行列配置对象, new时传入资源类型等参数</li><li>再写一个 Base类, 初始化通用的配置对象 有 initOptions initColumns 方法</li><li>各种资源类型继承 Base, 如果有不同,就在子类里重写 Base 中方法</li></ol><p><strong>结果</strong>: 组件中减少了很多重复判断代码, 结构也更清晰,每个资源有自己单独的文件,后续再新加资源也很方便</p><h2 id="资源界面前端实现联动查询" tabindex="-1">资源界面前端实现联动查询 <a class="header-anchor" href="#资源界面前端实现联动查询" aria-label="Permalink to &quot;资源界面前端实现联动查询&quot;">​</a></h2><p><strong>情境</strong>: 新版资源界面需优化用户体验, 要支持多条件联动查询主机和资源</p><p><strong>任务:</strong> 后台只返回主机,资源,实例的结果, 联动查询需在前端去实现; 上方需要统计主机状态,资源状态,实例类型,标签等,下方需要根据条件显示主机结果 [描述一些样式]</p><ul><li>因为主机&gt;资源&gt;实例, 数据中后者会包含前者的uuid, 怎么快速过滤出符合结果的主机是个问题, 比如选了主机在线, 资源已激活,实例类型mysql, 先去循环判断主机, 再从得出的结果中循环判断资源,再去判断实例,就比较多层了 解决方法: 主机,资源,实例会存到vuex中, resources页面用 computed 获取, 单独写了个hostFilter方法用于判断, 将资源和实例的状态数据作为一个参数 传入,形式是host uuid作为key, val是cache对象,</li><li>上方显示资源状态的时候已经计算过一次, 下方计算cache又算了一次. 于是上方用v-model双向绑定了一个变量,用来传递计算后的结果,格式如: { online: [ host_uuid..... ]}, 下方计算的时候,就判断是否在uuid数组里, 在就带上 key(online) , 然后此数组就作为上面 val cache 的一个字段, 后面 hostFilter 方法判断的时候就可以直接字符串比对这个数组 相当于之前 hostFilter 判断是 { online: [ uuid...] } , 用 hostuuid 遍历看是否包含其中, 现在 hostuuid 对应单独一个 cache 对象,直接从里面的instance_states 数据判断是否有 online 字符串就可以进行筛选</li><li>界面样式想实现窗口缩小宽度时, 放不下的项隐藏掉, 改用一个 ... 按钮代替,点击按钮展示所有项和勾选情况. 我将一行分为左右两部分,左边循环渲染选项,右边是 ... 按钮,用v-show控制显示, 用 window.addeventlistener 监听 resize 事件,因为左边是flex布局且换行,当换行后左部分的scrollHeight 会大于 clientHeight,就可以让按钮进行展示了下拉选择框, 同时下拉选择框是一个库,样式不太匹配,我就用:deep 样式穿透 隐藏了,然后监听按钮的点击来调用打开关闭来实现交互</li></ul><p>**行动:**如上</p><p><strong>结果:</strong></p><h2 id="封装高级搜索组件" tabindex="-1">封装高级搜索组件 <a class="header-anchor" href="#封装高级搜索组件" aria-label="Permalink to &quot;封装高级搜索组件&quot;">​</a></h2><p><strong>情境</strong>:</p><p><strong>任务:</strong></p><p><strong>行动:</strong></p><p><strong>结果:</strong></p><h2 id="项目优化情况" tabindex="-1">项目优化情况 <a class="header-anchor" href="#项目优化情况" aria-label="Permalink to &quot;项目优化情况&quot;">​</a></h2><ul><li>节流防抖</li><li>代码分割</li><li>路由懒加载</li><li>localstorage 缓存数据</li><li>避免重排/重绘</li><li>用 css 动画代替 js 动画</li><li>gzip压缩, vite用vite-plugin-compression</li><li>tree shaking, vite默认启用的</li><li>区分生产环境和开发环境做特殊处理</li><li>图片压缩</li><li>css避免深层嵌套</li></ul>',20)]))}const g=i(a,[["render",r]]);export{u as __pageData,g as default};
